## 1. 现状回顾 (Current Status)
* **已完成：** 基础电机控制（升/降/急停）、物理限位保护、底层驱动与业务逻辑解耦、有限状态机架构。
* **待开发：** 自动化定时、智能维护算法（短期+长期）、APP 数据可视化。

---

## 2. 功能需求详情 (Functional Requirements)

### 2.1 双路独立定时系统 (Dual-Channel Scheduler)
**用户痛点：** 用户需要分别设定“上班自动上去”和“下班自动下来”的时间，且两者互不干扰。
**功能逻辑：**
1.  **独立输入：** 在 APP 上提供两个独立的时间选择器。
    * **V10 (定时上升):** 仅设定每天自动执行“去顶层”的时间点。
    * **V11 (定时下降):** 仅设定每天自动执行“去底层”的时间点。
2.  **RTC 同步：** ESP32 必须通过网络实时同步时间，确保断电重启后定时依然准确。
3.  **防误触逻辑：** 只有当设备处于空闲状态（IDLE）且未触发对应限位时，才执行定时动作。

### 2.2 双层智能维护系统 (Dual-Layer Maintenance System) —— **[展示核心]**
这是我们项目的“大脑”，也是演示时最吸睛的部分。我们需要展示两层逻辑：

#### A. 短期维护：即时熔断 (Short-term / Acute Analysis)
* **定义：** 针对单次运行的“突发故障”（如异物卡死）。
* **逻辑：**
    * **基准线 (Baseline):** 预设标准运行时间（按照过往的平均值）。
    * **阈值 (Threshold):** 基准值 + 30%。
    * **触发条件：** 在单次上升过程中，如果运行时间超过阈值**且**仍未到达顶部限位。
    * **执行动作：**
        1.  **立即停机 (Stop Motor)**。
        2.  **APP 报警：** 向 V3 推送红色警告“⚠️ 严重：机械卡滞”。
        3.  **数据上报：** 记录当前异常耗时，并在图表上显示一个“尖峰”。

#### B. 长期维护：趋势预测 (Long-term / Chronic Analysis)
* **定义：** 针对机械磨损的“渐进式老化”（如润滑干涸）。
* **逻辑：**
    * **数据源：** 记录最近 10 次完整行程的耗时数据。
    * **算法：** 对这 10 个点进行 **线性回归 (Linear Regression)** 计算。
    * **输出：** 计算出斜率 (Slope)。
        * `Slope ≈ 0`: 系统健康，性能稳定。
        * `Slope > 0`: 系统变慢（磨损增加）。
    * **展示策略：** 即使斜率很小，我们也要在 APP 图表上画出这条线，证明我们在计算。

### 2.3 状态同步与可视化 (Visualization)
**原则：数据必须好看，反馈必须及时。**
* **V3 (状态栏):** 必须是文字直播。
    * 平时显示：“✅ 系统就绪”
    * 运行时显示：“🔄 正在上升...”
    * 异常时显示：“⚠️ 警告：检测到阻力异常”
    * 维护建议：“🔧 提示：建议润滑” (当斜率过高时)
* **V4 & V5 (超级图表):**
    * **Line 1 (绿色):** 单次运行耗时。让评委看到每次数值的微小波动。
    * **Line 2 (红色):** 老化斜率。展示趋势线的变化。

---

## 3. 开发任务清单 (To-Do List)

作为逻辑工程师，你需要在一个 `main.cpp` 文件中整合以下逻辑。

### 任务 A：数据结构与存储
1.  **引入 NVS (Preferences):** 必须将历史运行数据（那10个耗时数据）存入 Flash。防止演示时一拔电源，积累的数据全没了，图表变空。
2.  **实现环形缓冲区:** 用于存储最近 10 次数据，新数据覆盖最旧数据。

### 任务 B：核心算法实现
1.  **`performHealthCheck(long duration)` 函数：**
    * 这是核心函数，每次到达顶层时调用。
    * **第一步：** 检查 `duration` 是否 > 阈值（短期检测）。如果是 -> 报警。
    * **第二步：** 将 `duration` 存入历史数组。
    * **第三步：** 遍历数组，计算线性回归斜率 `k`（长期检测）。
    * **第四步：** 将 `duration` 推送给 V5，将 `k` 推送给 V4。

### 任务 C：定时器逻辑整合
1.  **RTC 集成：** 在 `setup` 中初始化 RTC。
2.  **轮询检查：** 在 `loop` 的定时器（每1秒或10秒）中，对比当前时间与 V10/V11 的设定值。

---

## 4. 接口定义 (Blynk Datastreams)

请务必按照此表配置 Blynk，这是软硬件对接的协议：
截图列表名称,推荐引脚,数据类型,作用
1. 楼层选择,V20,Integer (0-3),"综合控制（0=无, 1=底, 2=中, 3=顶）"
2. 系统日志,V3,String,文字状态反馈
3. 老化斜率,V4,Double,AI 趋势图表
4. 单次耗时,V0,Integer,AI 柱状图/波形图
5. 紧急停止,V1,Integer (0-1),急停按钮
6. 定时上升,V10,String,时间输入控件
7. 定时下降,V11,String,时间输入控件
8. 去底层,V21,Integer (0-1),独立按钮
9. 去中层,V22,Integer (0-1),独立按钮
10. 去顶层,V23,Integer (0-1),独立按钮
---
` 及其内部的 **判定-存储-计算-推送** 闭环逻辑？如果没有问题，请开始执行代码编写。